//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.3.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace Optris.OtcSDK {
///  Creates false color images from thermal frames.

public class ImageBuilder : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal ImageBuilder(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(ImageBuilder obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  internal static global::System.Runtime.InteropServices.HandleRef swigRelease(ImageBuilder obj) {
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
      global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.Dispose();
      return ptr;
    } else {
      return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
    }
  }

  ~ImageBuilder() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          otcsdkPINVOKE.delete_ImageBuilder(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  /// <summary>Constructor.</summary>
  /// Be mindful of which color format and width alignment you choose. Please refer to the documentation of the
  /// enums for more details.
  /// <param name="colorFormat">    for the generated false color image.</param> 
  /// <param name="widthAlignment"> for the generated false color image.</param>
  public ImageBuilder(ColorFormat colorFormat, WidthAlignment widthAlignment) : this(otcsdkPINVOKE.new_ImageBuilder((int)colorFormat, (int)widthAlignment), true) {
  }

  /// <summary>Sets a new thermal frame.</summary>
  /// The provide frame will be copied to an internal buffer.
  /// <param name="thermalFrame"> data.</param>
  public void setThermalFrame(ThermalFrame thermalFrame) {
    otcsdkPINVOKE.ImageBuilder_setThermalFrame(swigCPtr, ThermalFrame.getCPtr(thermalFrame));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Grants read access to the stored thermal frame.</summary>
  /// <returns>const reference to the stored thermal frame.</returns>
  public ThermalFrame getThermalFrame() {
  global::System.IntPtr cPtr = otcsdkPINVOKE.ImageBuilder_getThermalFrame(swigCPtr);
  ThermalFrame ret = null;
  if (cPtr != global::System.IntPtr.Zero) {
    ret = new ThermalFrame(cPtr, false);
    ret.addReference(this);
  }
  return ret;
}

  /// <summary>Returns the width in pixels of the thermal frame.</summary>
  /// <returns>width in pixels of the thermal frame.</returns>
  public int getWidth() {
    int ret = otcsdkPINVOKE.ImageBuilder_getWidth(swigCPtr);
    return ret;
  }

  /// <summary>Returns the height in pixels of thermal frame.</summary>
  /// <returns>height in pixels of thermal frame.</returns>
  public int getHeight() {
    int ret = otcsdkPINVOKE.ImageBuilder_getHeight(swigCPtr);
    return ret;
  }

  /// <summary>Returns the temperature the from last acquired image at specified pixel index.</summary>
  /// <param name="index"> pixel index.</param> 
  /// <returns>temperature in °C.</returns> 
  /// <exception cref="SDKException"> if index is out of range.</exception>
  public float getTemperature(int index) {
    float ret = otcsdkPINVOKE.ImageBuilder_getTemperature__SWIG_0(swigCPtr, index);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the temperature from last acquired image at specified pixel coordinates.</summary>
  /// The origin of coordinates is located in the upper left corner with the x-axis pointing right and
  /// the y-axis pointing downwards.
  /// <param name="x"> coordinates.</param> 
  /// <param name="y"> coordinates.</param> 
  /// <returns>temperature in °C.</returns> 
  /// <exception cref="SDKException"> if coordinates are out of range.</exception>
  public float getTemperature(int x, int y) {
    float ret = otcsdkPINVOKE.ImageBuilder_getTemperature__SWIG_1(swigCPtr, x, y);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the mean temperature in °C of a rectangular region.</summary>
  /// Before providing the region to this method you have to define the rectangular area it covers by
  /// specifying its upper left and lower right corners.
  /// <param name="meanRegion"> in which to calculate the mean temperature.</param> 
  /// <returns>true if a mean temperature could be calculated. False if no thermal data is available or
  ///             if the region coordinates are inconstent or if the region is too large for the frame.</returns>
  public bool getMeanTemperatureInRegion(TemperatureRegion meanRegion) {
    bool ret = otcsdkPINVOKE.ImageBuilder_getMeanTemperatureInRegion(swigCPtr, TemperatureRegion.getCPtr(meanRegion));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the region of minimum/maximum temperature in °C with the given radius.</summary>
  /// The method will fill in all the data for the min and max temperature region.
  /// <param name="radius">    radius of the region.</param> 
  /// <param name="minRegion"> region of minimum mean temperature.</param> 
  /// <param name="maxRegion"> region of maximum mean temperature.</param> 
  /// <returns>true if minimum/maximum temperature could be calculated. False if no thermal data is available
  ///             or if the radius is to large for the frame.</returns>
  public bool getMinMaxRegions(int radius, TemperatureRegion minRegion, TemperatureRegion maxRegion) {
    bool ret = otcsdkPINVOKE.ImageBuilder_getMinMaxRegions(swigCPtr, radius, TemperatureRegion.getCPtr(minRegion), TemperatureRegion.getCPtr(maxRegion));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Sets the temperature range for the manual scaling method.</summary>
  /// <param name="min"> lower limit in °C.</param> 
  /// <param name="max"> upper limit in °C.</param>
  public void setManualTemperatureRange(float min, float max) {
    otcsdkPINVOKE.ImageBuilder_setManualTemperatureRange(swigCPtr, min, max);
  }

  /// <summary>Returns the minimum temperature used to scale the image.</summary>
  /// <returns>temperature in °C.</returns>
  public float getIsothermalMin() {
    float ret = otcsdkPINVOKE.ImageBuilder_getIsothermalMin(swigCPtr);
    return ret;
  }

  /// <summary>Returns the maximum temperature used to scale the image.</summary>
  /// <returns>Temperature in °C</returns>
  public float getIsothermalMax() {
    float ret = otcsdkPINVOKE.ImageBuilder_getIsothermalMax(swigCPtr);
    return ret;
  }

  /// <summary>Sets the scaling method for the false color conversion.</summary>
  /// <param name="method"> scaling method.</param>
  public void setPaletteScalingMethod(PaletteScalingMethod method) {
    otcsdkPINVOKE.ImageBuilder_setPaletteScalingMethod(swigCPtr, (int)method);
  }

  /// <summary>Returns the current scaling method for the false color conversion.</summary>
  /// <returns>scaling method.</returns>
  public PaletteScalingMethod getPaletteScalingMethod() {
    PaletteScalingMethod ret = (PaletteScalingMethod)otcsdkPINVOKE.ImageBuilder_getPaletteScalingMethod(swigCPtr);
    return ret;
  }

  /// <summary>Sets the palette for the false color conversion.</summary>
  /// <param name="palette"> coloring palette to set.</param>
  public void setPalette(ColoringPalette palette) {
    otcsdkPINVOKE.ImageBuilder_setPalette(swigCPtr, (int)palette);
  }

  /// <summary>Returns the palette for the false color conversion.</summary>
  /// <returns>used coloring palette.</returns>
  public ColoringPalette getPalette() {
    ColoringPalette ret = (ColoringPalette)otcsdkPINVOKE.ImageBuilder_getPalette(swigCPtr);
    return ret;
  }

  /// <summary>Grants read access to the generated false color image.</summary>
  /// <returns>const reference to the generated false color image.</returns>
  public Image getImage() {
  global::System.IntPtr cPtr = otcsdkPINVOKE.ImageBuilder_getImage(swigCPtr);
  Image ret = null;
  if (cPtr != global::System.IntPtr.Zero) {
    ret = new Image(cPtr, false);
    ret.addReference(this);
  }
  return ret;
}

  /// <summary>Returns the image size in bytes including potential width padding.</summary>
  /// <returns>image size in bytes including potential width padding.</returns>
  public int getImageSizeInBytes() {
    int ret = otcsdkPINVOKE.ImageBuilder_getImageSizeInBytes(swigCPtr);
    return ret;
  }

  /// <summary>Returns the image stride in bytes.</summary>
  /// The stride is the image width in bytes including potential padding.
  /// <returns>image stride in bytes.</returns>
  public int getImageStride() {
    int ret = otcsdkPINVOKE.ImageBuilder_getImageStride(swigCPtr);
    return ret;
  }

  /// <summary>Copies the false color image data to the given destination array.</summary>
  /// <param name="destination"> array to copy the false color image data to.</param> 
  /// <param name="size">        in bytes. The specified size is limited to [0, image size in bytes].</param>
  public void copyImageDataTo(byte[] destination, int size) {
    otcsdkPINVOKE.ImageBuilder_copyImageDataTo(swigCPtr, destination, size);
  }

  ///  Triggers the image conversion.
  public void convertTemperatureToPaletteImage() {
    otcsdkPINVOKE.ImageBuilder_convertTemperatureToPaletteImage(swigCPtr);
  }

}

}
