//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.3.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace Optris.OtcSDK {
/// <summary>Encapsulates false color images with 8-bit color depth.</summary>
/// The individual pixel values, like red, green or blue, are stored in a one-dimensional array.
/// Depending on the width alignment additional bytes may be added at the end of each row to ensure
/// that its size in bytes respects this alignment. The setter and getter functions as well as the
/// iterators will skip this padding.
/// The origin of coordinates is located in the upper left corner with the x-axis pointing right and
/// the y-axis pointing down.

public class Image : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal Image(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Image obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  internal static global::System.Runtime.InteropServices.HandleRef swigRelease(Image obj) {
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
      global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.Dispose();
      return ptr;
    } else {
      return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
    }
  }

  ~Image() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          otcsdkPINVOKE.delete_Image(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  // Store a reference to the image builder to avoid premature garbage collection
  private ImageBuilder imageBuilderReference;
  internal void addReference(ImageBuilder builder) {
    imageBuilderReference = builder;
  }

  /// <summary>Constructor.</summary>
  /// <param name="colorFormat">    defines the sequence in which the pixel values are stored internally.</param> 
  /// <param name="widthAlignment"> defines the alignment of the row size in bytes. If, e.g., it is set to
  ///                               four bytes, the row size will potentially be padded at the end so that
  ///                               it is a multiple of four.</param>
  public Image(ColorFormat colorFormat, WidthAlignment widthAlignment) : this(otcsdkPINVOKE.new_Image((int)colorFormat, (int)widthAlignment), true) {
  }

  /// <summary>Returns the pixel at the given index.</summary>
  /// <param name="index"> of the desired pixel.</param> 
  /// <returns>the pixel at the given index.</returns> 
  /// <exception cref="SDKException"> if the index is out of bounds.</exception>
  public Pixel getPixel(int index) {
    Pixel ret = new Pixel(otcsdkPINVOKE.Image_getPixel__SWIG_0(swigCPtr, index), true);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the pixel at the given coordinates.</summary>
  /// <param name="x"> coordinate.</param> 
  /// <param name="y"> coordinate.</param> 
  /// <returns>the pixel at the given coordinates.</returns> 
  /// <exception cref="SDKException"> if the coordinates are out of bounds.</exception>
  public Pixel getPixel(int x, int y) {
    Pixel ret = new Pixel(otcsdkPINVOKE.Image_getPixel__SWIG_1(swigCPtr, x, y), true);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Sets the pixel at the given index.</summary>
  /// <param name="index"> of the pixel to set.</param> 
  /// <param name="pixel"> to set.</param> 
  /// <exception cref="SDKException"> if the index is out of bounds.</exception>
  public void setPixel(int index, Pixel pixel) {
    otcsdkPINVOKE.Image_setPixel__SWIG_0(swigCPtr, index, Pixel.getCPtr(pixel));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Sets the pixel at the given coordinates.</summary>
  /// <param name="x">     coordinate.</param> 
  /// <param name="y">     coordinate.</param> 
  /// <param name="pixel"> to set.</param> 
  /// <exception cref="SDKException"> if the coordinates are out of bounds.</exception>
  public void setPixel(int x, int y, Pixel pixel) {
    otcsdkPINVOKE.Image_setPixel__SWIG_1(swigCPtr, x, y, Pixel.getCPtr(pixel));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns an iterator with read and write access.</summary>
  /// The iterator traverses the image in a row major fashion and skips potential width padding.
  /// <returns>iterator with read and write access.</returns>
  public ImageIterator getIterator() {
    ImageIterator ret = new ImageIterator(otcsdkPINVOKE.Image_getIterator(swigCPtr), true);
    return ret;
  }

  /// <summary>Returns an iterator with read access.</summary>
  /// The iterator traverses the image in a row major fashion and skips potential width padding.
  /// <returns>iterator with read access.</returns>
  public ConstImageIterator getConstIterator() {
    ConstImageIterator ret = new ConstImageIterator(otcsdkPINVOKE.Image_getConstIterator(swigCPtr), true);
    return ret;
  }

  /// <summary>Returns the width of the image in pixels.</summary>
  /// <returns>image width in pixels.</returns>
  public int getWidth() {
    int ret = otcsdkPINVOKE.Image_getWidth(swigCPtr);
    return ret;
  }

  /// <summary>Returns the stride of the image in bytes.</summary>
  /// The stride is the image width in bytes including potential padding.
  /// <returns>stride of the image in bytes.</returns>
  public int getStride() {
    int ret = otcsdkPINVOKE.Image_getStride(swigCPtr);
    return ret;
  }

  /// <summary>Returns the height of the image in pixels.</summary>
  /// <returns>image height in pixels.</returns>
  public int getHeight() {
    int ret = otcsdkPINVOKE.Image_getHeight(swigCPtr);
    return ret;
  }

  /// <summary>Returns the size of the image as total number of pixels.</summary>
  /// <returns>size of the image as total number of pixels.</returns>
  public int getSize() {
    int ret = otcsdkPINVOKE.Image_getSize(swigCPtr);
    return ret;
  }

  /// <summary>Returns the size of the internal storage in bytes.</summary>
  /// This includes potential width padding.
  /// <returns>size of the internal storage in bytes.</returns>
  public int getSizeInBytes() {
    int ret = otcsdkPINVOKE.Image_getSizeInBytes(swigCPtr);
    return ret;
  }

  /// <summary>Returns whether the image is empty.</summary>
  /// <returns>true if the image is empty. False otherwise.</returns>
  public bool isEmpty() {
    bool ret = otcsdkPINVOKE.Image_isEmpty(swigCPtr);
    return ret;
  }

  ///  Clears the image.
  public void clear() {
    otcsdkPINVOKE.Image_clear(swigCPtr);
  }

  /// <summary>Resizes the image to the given dimensions.</summary>
  /// <param name="width">  in pixels.</param> 
  /// <param name="height"> in pixels.</param>
  public void resize(int width, int height) {
    otcsdkPINVOKE.Image_resize(swigCPtr, width, height);
  }

  /// <summary>Returns the color format.</summary>
  /// <returns>color format.</returns>
  public ColorFormat getColorFormat() {
    ColorFormat ret = (ColorFormat)otcsdkPINVOKE.Image_getColorFormat(swigCPtr);
    return ret;
  }

  /// <summary>Returns the width alignment.</summary>
  /// <returns>width alignment.</returns>
  public WidthAlignment getWidthAlignment() {
    WidthAlignment ret = (WidthAlignment)otcsdkPINVOKE.Image_getWidthAlignment(swigCPtr);
    return ret;
  }

  /// <summary>Returns a complete copy of this image.</summary>
  /// <returns>complete copy of this image.</returns>
  public Image clone() {
    Image ret = new Image(otcsdkPINVOKE.Image_clone(swigCPtr), true);
    return ret;
  }

  /// <summary>Copies the internally stored pixel values to the given array.</summary>
  /// This includes potential width padding.
  /// <remarks>No range checks are performed. The correct size of the destination array</remarks><param name="destination"> array to copy the data to.</param> 
  /// <param name="size">        in bytes. The specified size is limited to [0, frame size in bytes].</param> 
  /// <seealso cref="getSizeInBytes"/>
  public void copyDataTo(byte[] destination, int size) {
    otcsdkPINVOKE.Image_copyDataTo(swigCPtr, destination, size);
  }

}

}
