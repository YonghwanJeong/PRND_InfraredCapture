//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.3.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace Optris.OtcSDK {
/// <summary>Base class for clients observing an IRImager.</summary>
/// The architecture is following the Observer design pattern. To receive data like thermal frames from your device
/// derive your own class from it and implement the callback methods. After creating an instance of you need to
/// register it with an IRImager object by calling its IRImager::addClient() method.

public class IRImagerClient : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal IRImagerClient(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(IRImagerClient obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  internal static global::System.Runtime.InteropServices.HandleRef swigRelease(IRImagerClient obj) {
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
      global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.Dispose();
      return ptr;
    } else {
      return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
    }
  }

  ~IRImagerClient() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          otcsdkPINVOKE.delete_IRImagerClient(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  ///  Constructor.
  public IRImagerClient() : this(otcsdkPINVOKE.new_IRImagerClient__SWIG_0(), true) {
    SwigDirectorConnect();
  }

  ///  No copy constructor.
  public IRImagerClient(IRImagerClient arg0) : this(otcsdkPINVOKE.new_IRImagerClient__SWIG_1(IRImagerClient.getCPtr(arg0)), true) {
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    SwigDirectorConnect();
  }

  /// <summary>Callback method for thermal frames.</summary>
  /// The provided references will remain valid outside the callback but the data that they are pointing to will be
  /// overwritten. Make a copy (C++) or use the clone() method (other languages) if you want to use them outside of
  /// the callback.
  /// The references are const. Thus, you have only read access to the objects they are referring to. Attempts to
  /// manipulate their content will cause issues.
  /// This callback will also be triggered during the initial startup calibration phase following a successful device
  /// connection. During this time the thermal data is unreliable. You can detect this phase by checking whether the
  /// flag state stored in the meta data (FrameMetadata::getFlagState()) is set to Initializing.
  /// <param name="thermal"> frame.</param> 
  /// <param name="meta">    additional meta data.</param>
  public virtual void onThermalFrame(ThermalFrame thermal, FrameMetadata meta) {
    if (SwigDerivedClassHasMethod("onThermalFrame", swigMethodTypes0)) otcsdkPINVOKE.IRImagerClient_onThermalFrameSwigExplicitIRImagerClient(swigCPtr, ThermalFrame.getCPtr(thermal), FrameMetadata.getCPtr(meta)); else otcsdkPINVOKE.IRImagerClient_onThermalFrame(swigCPtr, ThermalFrame.getCPtr(thermal), FrameMetadata.getCPtr(meta));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Callback method for thermal frames triggered with a raising edge event on PIF digital input or software       trigger.</summary>
  /// The provided references will remain valid outside the callback but the data that they are pointing to will be
  /// overwritten. Make a copy (C++) or use the clone() method (other languages) if you want to use them outside of
  /// the callback.
  /// The references are const. Thus, you have only read access to the objects they are referring to. Attempts to
  /// manipulate their content will cause issues.
  /// For future use.
  /// <param name="thermal"> frame.</param> 
  /// <param name="energy">  frame.</param> 
  /// <param name="meta">    additional meta data for both frames.</param> 
  /// <param name="events">  snapshot events.</param>
  public virtual void onThermalFrameEvent(ThermalFrame thermal, Frame energy, FrameMetadata meta, SnapshotEventVector events) {
    if (SwigDerivedClassHasMethod("onThermalFrameEvent", swigMethodTypes1)) otcsdkPINVOKE.IRImagerClient_onThermalFrameEventSwigExplicitIRImagerClient(swigCPtr, ThermalFrame.getCPtr(thermal), Frame.getCPtr(energy), FrameMetadata.getCPtr(meta), SnapshotEventVector.getCPtr(events)); else otcsdkPINVOKE.IRImagerClient_onThermalFrameEvent(swigCPtr, ThermalFrame.getCPtr(thermal), Frame.getCPtr(energy), FrameMetadata.getCPtr(meta), SnapshotEventVector.getCPtr(events));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Callback method for flag state events. The method is called when the flag state changes.</summary>
  /// <param name="flagState"> current flag state.</param>
  public virtual void onFlagStateChange(FlagState flagState) {
    if (SwigDerivedClassHasMethod("onFlagStateChange", swigMethodTypes2)) otcsdkPINVOKE.IRImagerClient_onFlagStateChangeSwigExplicitIRImagerClient(swigCPtr, (int)flagState); else otcsdkPINVOKE.IRImagerClient_onFlagStateChange(swigCPtr, (int)flagState);
  }

  /// <summary>Callback method for measurement fields. The method is called when the calculation has finished.</summary>
  /// The provided reference will remain valid outside the callback but the data that it is pointing to will be
  /// overwritten. Make a copy (C++) or use the clone() method (other languages) if you want to use it outside
  /// of the callback.
  /// The reference is const. Thus, you have only read access to the object it is referring to. Attempts to
  /// manipulate its content will cause issues.
  /// <param name="field"> measurement field.</param>
  public virtual void onMeasurementField(MeasurementField field) {
    if (SwigDerivedClassHasMethod("onMeasurementField", swigMethodTypes3)) otcsdkPINVOKE.IRImagerClient_onMeasurementFieldSwigExplicitIRImagerClient(swigCPtr, MeasurementField.getCPtr(field)); else otcsdkPINVOKE.IRImagerClient_onMeasurementField(swigCPtr, MeasurementField.getCPtr(field));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Called when a connection loss is detected.</summary>
  /// A connection loss can not be recovered. This happens, for example, if the USB connection is interrupted by
  /// pulling the plug.
  /// It is up to the client to call IRImager:disconnect(). This gives the client the ability to ensure a graceful
  /// disconnect on its end.
  public virtual void onConnectionLost() {
    if (SwigDerivedClassHasMethod("onConnectionLost", swigMethodTypes4)) otcsdkPINVOKE.IRImagerClient_onConnectionLostSwigExplicitIRImagerClient(swigCPtr); else otcsdkPINVOKE.IRImagerClient_onConnectionLost(swigCPtr);
  }

  /// <summary>Called when a connection timeout is detected.</summary>
  /// Unlike with connection losses you may recover from a timeout.
  /// Connection timeouts are the only way to detect connection losses with Ethernet devices. This is due to the
  /// fact that these devices continuously send UDP packages once they are powered. Besides receiving these packages
  /// the SDK has no way of knowing whether the connection is lost.
  /// It is up to the client to call IRImager:disconnect(). This gives the client the ability to ensure a graceful
  /// disconnect on its end.
  public virtual void onConnectionTimeout() {
    if (SwigDerivedClassHasMethod("onConnectionTimeout", swigMethodTypes5)) otcsdkPINVOKE.IRImagerClient_onConnectionTimeoutSwigExplicitIRImagerClient(swigCPtr); else otcsdkPINVOKE.IRImagerClient_onConnectionTimeout(swigCPtr);
  }

  /// <summary>Callback method for synchronizing data. This is the very last method to be called for each raw data set.</summary>
  public virtual void onProcessExit() {
    if (SwigDerivedClassHasMethod("onProcessExit", swigMethodTypes6)) otcsdkPINVOKE.IRImagerClient_onProcessExitSwigExplicitIRImagerClient(swigCPtr); else otcsdkPINVOKE.IRImagerClient_onProcessExit(swigCPtr);
  }

  private void SwigDirectorConnect() {
    if (SwigDerivedClassHasMethod("onThermalFrame", swigMethodTypes0))
      swigDelegate0 = new SwigDelegateIRImagerClient_0(SwigDirectorMethodonThermalFrame);
    if (SwigDerivedClassHasMethod("onThermalFrameEvent", swigMethodTypes1))
      swigDelegate1 = new SwigDelegateIRImagerClient_1(SwigDirectorMethodonThermalFrameEvent);
    if (SwigDerivedClassHasMethod("onFlagStateChange", swigMethodTypes2))
      swigDelegate2 = new SwigDelegateIRImagerClient_2(SwigDirectorMethodonFlagStateChange);
    if (SwigDerivedClassHasMethod("onMeasurementField", swigMethodTypes3))
      swigDelegate3 = new SwigDelegateIRImagerClient_3(SwigDirectorMethodonMeasurementField);
    if (SwigDerivedClassHasMethod("onConnectionLost", swigMethodTypes4))
      swigDelegate4 = new SwigDelegateIRImagerClient_4(SwigDirectorMethodonConnectionLost);
    if (SwigDerivedClassHasMethod("onConnectionTimeout", swigMethodTypes5))
      swigDelegate5 = new SwigDelegateIRImagerClient_5(SwigDirectorMethodonConnectionTimeout);
    if (SwigDerivedClassHasMethod("onProcessExit", swigMethodTypes6))
      swigDelegate6 = new SwigDelegateIRImagerClient_6(SwigDirectorMethodonProcessExit);
    otcsdkPINVOKE.IRImagerClient_director_connect(swigCPtr, swigDelegate0, swigDelegate1, swigDelegate2, swigDelegate3, swigDelegate4, swigDelegate5, swigDelegate6);
  }

  private bool SwigDerivedClassHasMethod(string methodName, global::System.Type[] methodTypes) {
    global::System.Reflection.MethodInfo[] methodInfos = this.GetType().GetMethods(
        global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.NonPublic | global::System.Reflection.BindingFlags.Instance);
    foreach (global::System.Reflection.MethodInfo methodInfo in methodInfos) {
      if (methodInfo.DeclaringType == null)
        continue;

      if (methodInfo.Name != methodName)
        continue;

      var parameters = methodInfo.GetParameters();
      if (parameters.Length != methodTypes.Length)
        continue;

      bool parametersMatch = true;
      for (var i = 0; i < parameters.Length; i++) {
        if (parameters[i].ParameterType != methodTypes[i]) {
          parametersMatch = false;
          break;
        }
      }

      if (!parametersMatch)
        continue;

      if (methodInfo.IsVirtual && (methodInfo.DeclaringType.IsSubclassOf(typeof(IRImagerClient))) &&
        methodInfo.DeclaringType != methodInfo.GetBaseDefinition().DeclaringType) {
        return true;
      }
    }

    return false;
  }

  private void SwigDirectorMethodonThermalFrame(global::System.IntPtr thermal, global::System.IntPtr meta) {
    onThermalFrame(new ThermalFrame(thermal, false), new FrameMetadata(meta, false));
  }

  private void SwigDirectorMethodonThermalFrameEvent(global::System.IntPtr thermal, global::System.IntPtr energy, global::System.IntPtr meta, global::System.IntPtr events) {
    onThermalFrameEvent(new ThermalFrame(thermal, false), new Frame(energy, false), new FrameMetadata(meta, false), new SnapshotEventVector(events, false));
  }

  private void SwigDirectorMethodonFlagStateChange(int flagState) {
    onFlagStateChange((FlagState)flagState);
  }

  private void SwigDirectorMethodonMeasurementField(global::System.IntPtr field) {
    onMeasurementField(new MeasurementField(field, false));
  }

  private void SwigDirectorMethodonConnectionLost() {
    onConnectionLost();
  }

  private void SwigDirectorMethodonConnectionTimeout() {
    onConnectionTimeout();
  }

  private void SwigDirectorMethodonProcessExit() {
    onProcessExit();
  }

  public delegate void SwigDelegateIRImagerClient_0(global::System.IntPtr thermal, global::System.IntPtr meta);
  public delegate void SwigDelegateIRImagerClient_1(global::System.IntPtr thermal, global::System.IntPtr energy, global::System.IntPtr meta, global::System.IntPtr events);
  public delegate void SwigDelegateIRImagerClient_2(int flagState);
  public delegate void SwigDelegateIRImagerClient_3(global::System.IntPtr field);
  public delegate void SwigDelegateIRImagerClient_4();
  public delegate void SwigDelegateIRImagerClient_5();
  public delegate void SwigDelegateIRImagerClient_6();

  private SwigDelegateIRImagerClient_0 swigDelegate0;
  private SwigDelegateIRImagerClient_1 swigDelegate1;
  private SwigDelegateIRImagerClient_2 swigDelegate2;
  private SwigDelegateIRImagerClient_3 swigDelegate3;
  private SwigDelegateIRImagerClient_4 swigDelegate4;
  private SwigDelegateIRImagerClient_5 swigDelegate5;
  private SwigDelegateIRImagerClient_6 swigDelegate6;

  private static global::System.Type[] swigMethodTypes0 = new global::System.Type[] { typeof(ThermalFrame), typeof(FrameMetadata) };
  private static global::System.Type[] swigMethodTypes1 = new global::System.Type[] { typeof(ThermalFrame), typeof(Frame), typeof(FrameMetadata), typeof(SnapshotEventVector) };
  private static global::System.Type[] swigMethodTypes2 = new global::System.Type[] { typeof(FlagState) };
  private static global::System.Type[] swigMethodTypes3 = new global::System.Type[] { typeof(MeasurementField) };
  private static global::System.Type[] swigMethodTypes4 = new global::System.Type[] {  };
  private static global::System.Type[] swigMethodTypes5 = new global::System.Type[] {  };
  private static global::System.Type[] swigMethodTypes6 = new global::System.Type[] {  };
}

}
