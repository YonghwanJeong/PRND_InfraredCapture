//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.3.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace Optris.OtcSDK {
///  Common interface for all classes representing Optris thermal cameras.

public class IRImager : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  private bool swigCMemOwnBase;

  internal IRImager(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwnBase = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(IRImager obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~IRImager() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwnBase) {
          swigCMemOwnBase = false;
          otcsdkPINVOKE.delete_IRImager(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  /// <summary>Connects to the device with the given configuration.</summary>
  /// <remarks>A configuration with a serial number of 0 will be rejected.</remarks>
  /// <param name="config"> configuration.</param> 
  /// <exception cref="SDKException"> if connecting fails.</exception>
  public virtual void connect(IRImagerConfig config) {
    otcsdkPINVOKE.IRImager_connect__SWIG_0(swigCPtr, IRImagerConfig.getCPtr(config));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Connects to the device with the given device information.</summary>
  /// If the serial number is set to 0, the SDK will use the `EnumerationManager` to find a device to connect to. This
  ///       currently works only for a single USB device.
  /// <param name="deviceInfo"> device information.</param> 
  /// <exception cref="SDKException"> if connecting fails.</exception>
  public virtual void connect(DeviceInfo deviceInfo) {
    otcsdkPINVOKE.IRImager_connect__SWIG_1(swigCPtr, DeviceInfo.getCPtr(deviceInfo));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Connects to the device with the given serial number.</summary>
  /// If the serial number is set to 0, the SDK will use the `EnumerationManager` to find a device to connect to. This
  ///       currently works only for a single USB device.
  /// <param name="serialNumber"> of the device.</param> 
  /// <exception cref="SDKException"> if connecting fails.</exception>
  public virtual void connect(uint serialNumber) {
    otcsdkPINVOKE.IRImager_connect__SWIG_2(swigCPtr, serialNumber);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  ///  Disconnects from the current device.
  public virtual void disconnect() {
    otcsdkPINVOKE.IRImager_disconnect(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns whether a connection is established.</summary>
  /// <returns>true if a connection is established. False otherwise.</returns>
  public virtual bool isConnected() {
    bool ret = otcsdkPINVOKE.IRImager_isConnected(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Adds an observer/client that will be updated when new data arrives.</summary>
  /// <param name="client"> callback client.</param>
  public virtual void addClient(IRImagerClient client) {
    otcsdkPINVOKE.IRImager_addClient(swigCPtr, IRImagerClient.getCPtr(client));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Removes the given observer/client.</summary>
  /// <param name="client"> to remove.</param> 
  /// <returns>true, if the client was removed. False otherwise.</returns>
  public virtual bool removeClient(IRImagerClient client) {
    bool ret = otcsdkPINVOKE.IRImager_removeClient(swigCPtr, IRImagerClient.getCPtr(client));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Runs the processing loop continuously.</summary>
  /// Blocks until stopRunning() or disconnect() is called from another thread or until the application
  /// terminates.
  /// <seealso cref="stopRunning"/>
  public virtual void run() {
    otcsdkPINVOKE.IRImager_run(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Runs the processing loop continuously in a dedicated thread.</summary>
  /// Runs until stopRunning() or disconnect() is called from another thread or until the application
  /// terminates.
  /// All callback methods of a registered client now are called from this processing thread.
  /// <returns>true if the thread started within a second. False otherwise.</returns> 
  /// <seealso cref="stopRunning"/>
  public virtual bool runAsync() {
    bool ret = otcsdkPINVOKE.IRImager_runAsync(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  ///  Stops the continuously running processing loop.
  public virtual void stopRunning() {
    otcsdkPINVOKE.IRImager_stopRunning(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns whether the processing loop is currently running.</summary>
  /// <returns>true if the processing loop is running. False otherwise.</returns>
  public virtual bool isRunning() {
    bool ret = otcsdkPINVOKE.IRImager_isRunning(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Adds a measurement field that is processed for every new thermal frame.</summary>
  /// The resulting data can be accessed via the IRImagerClient::onMeasurementField() callback.
  /// The IRImager creates an internal copy of the provided field. Any manipulation of the field after
  ///       it was added has no more effect on its processing.
  /// <param name="field"> measurement field to add.</param> 
  /// <exception cref="SDKException"> if not connected or the measurement field is not completely within the thermal frame
  ///                         or adding it failed.</exception>
  public virtual void addMeasurementField(MeasurementField field) {
    otcsdkPINVOKE.IRImager_addMeasurementField(swigCPtr, MeasurementField.getCPtr(field));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns the type of device the IRImager is connected to.</summary>
  /// <returns>type of device the IRImager is connected to or unknown if not connected.</returns>
  public virtual DeviceType getDeviceType() {
    DeviceType ret = (DeviceType)otcsdkPINVOKE.IRImager_getDeviceType(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the serial number of the connected device.</summary>
  /// <returns>serial number of the connected device or 0 if not connected.</returns>
  public virtual uint getSerialNumber() {
    uint ret = otcsdkPINVOKE.IRImager_getSerialNumber(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the hardware revision of the connected device.</summary>
  /// <returns>hardware revision number of the connected device or 0 if not connected.</returns>
  public virtual uint getHardwareRevision() {
    uint ret = otcsdkPINVOKE.IRImager_getHardwareRevision(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the firmware revision of the connected device.</summary>
  /// <returns>firmware revision number of the connected device or 0 if not connected.</returns>
  public virtual uint getFirmwareRevision() {
    uint ret = otcsdkPINVOKE.IRImager_getFirmwareRevision(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the operation modes for the currently connected device.</summary>
  /// Each operation mode holds a valid combination of optics, temperature range and video format settings
  /// for the currently connected device.
  /// <returns>operation modes for the currently connected device.</returns> 
  /// <exception cref="SDKException"> if not connected.</exception>
  public virtual OperationModeVector getOperationModes() {
    OperationModeVector ret = new OperationModeVector(otcsdkPINVOKE.IRImager_getOperationModes(swigCPtr), true);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Sets the automatic triggering of flag cycles en-/disabled.</summary>
  /// <param name="enable"> or disable automatic triggering of flag cycles.</param>
  public virtual void setAutoFlagEnabled(bool enable) {
    otcsdkPINVOKE.IRImager_setAutoFlagEnabled(swigCPtr, enable);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns whether flag cycles are triggered automatically.</summary>
  /// <returns>true, if flag cycles are triggered automatically. False is automatic triggering is diabled or if not connected.</returns>
  public virtual bool isAutoFlagEnabled() {
    bool ret = otcsdkPINVOKE.IRImager_isAutoFlagEnabled(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Sets the minimum and maximum flag intervals in seconds.</summary>
  /// <param name="minInterval"> minimal time in seconds that has to elapse before a new flag cycle is triggered.</param> 
  /// <param name="maxInterval"> maximum time in seconds that can elapse until a new flag cycle is triggered. Set to 0 to
  ///                            deactivate.</param> 
  /// <exception cref="SDKException"> if provided intervals are negative.</exception>
  public virtual void setFlagInterval(float minInterval, float maxInterval) {
    otcsdkPINVOKE.IRImager_setFlagInterval(swigCPtr, minInterval, maxInterval);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns the minimum flag interval in seconds.</summary>
  /// Minimum time that has to elapse before a new flag cycle is triggered.
  /// <returns>minimum flag interval in seconds or 0 if not connected.</returns>
  public virtual float getFlagMinInterval() {
    float ret = otcsdkPINVOKE.IRImager_getFlagMinInterval(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the maximum flag interval in seconds.</summary>
  /// Maximum time that can elapse before a new flag cycle is triggered.
  /// <returns>maximum flag interval in seconds or 0 if not connected.</returns>
  public virtual float getFlagMaxInterval() {
    float ret = otcsdkPINVOKE.IRImager_getFlagMaxInterval(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Force a flag cycle manually.</summary>
  /// <param name="time"> point of time in future in milliseconds, when the shutter flag should be closed.</param> 
  /// <exception cref="SDKException"> if not connected.</exception>
  public virtual void forceFlagEvent(float time) {
    otcsdkPINVOKE.IRImager_forceFlagEvent__SWIG_0(swigCPtr, time);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Force a flag cycle manually.</summary>
  /// <exception cref="SDKException"> if not connected.</exception>
  public virtual void forceFlagEvent() {
    otcsdkPINVOKE.IRImager_forceFlagEvent__SWIG_1(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns whether the shutter flag is open.</summary>
  /// <returns>true if the shutter flag is open. False if the shutter flag is closed or if not
  ///             connected.</returns>
  public virtual bool isFlagOpen() {
    bool ret = otcsdkPINVOKE.IRImager_isFlagOpen(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Set the shutter flag forecast en-/disabled.</summary>
  /// <param name="enable"> of disable the shutter flag forecast.</param> 
  /// <exception cref="SDKException"> if not connected.</exception>
  public virtual void setFlagForecastEnabled(bool enable) {
    otcsdkPINVOKE.IRImager_setFlagForecastEnabled(swigCPtr, enable);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns whether the shutter flag forecast is en-/disabled.</summary>
  /// <returns>true if the shutter flag forecast is enabled. False if flag forecast is disabled or if not
  ///             connected.</returns>
  public virtual bool isFlagForecastEnabled() {
    bool ret = otcsdkPINVOKE.IRImager_isFlagForecastEnabled(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the width in pixels of the thermal frame.</summary>
  /// <returns>width in pixels of the thermal frame, i.e. number of columns or 0 if not connected.</returns>
  public virtual int getWidth() {
    int ret = otcsdkPINVOKE.IRImager_getWidth(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the height in pixels of thermal frame.</summary>
  /// <returns>height in pixels of the thermal frame, i.e. number of rows or 0 if not connected.</returns>
  public virtual int getHeight() {
    int ret = otcsdkPINVOKE.IRImager_getHeight(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the temperature of the shutter flag in °C.</summary>
  /// <returns>temperature of the shutter flag in °C or INVALID_TEMPERATURE if not connected or
  ///             35.0 °C if connected but processing has not yet started (s. run() and runAsync()).</returns>
  public virtual float getTemperatureFlag() {
    float ret = otcsdkPINVOKE.IRImager_getTemperatureFlag(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the temperature of the device housing in °C.</summary>
  /// <returns>temperature of the device housing in °C or INVALID_TEMPERATURE if not connected or 35.0 °C
  ///             if connected but processing has not yet started (s. run() and runAsync()).</returns>
  public virtual float getTemperatureBox() {
    float ret = otcsdkPINVOKE.IRImager_getTemperatureBox(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the temperature of the sensor chip.</summary>
  /// <returns>temperature of the sensor chip in °C or INVALID_TEMPERATURE if not connected or
  ///             35.0 °C if connected but processing has not yet started (s. run() and runAsync()).</returns>
  public virtual float getTemperatureChip() {
    float ret = otcsdkPINVOKE.IRImager_getTemperatureChip(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Enables the heating of the sensor chip.</summary>
  /// <param name="enable"> indicates whether to enable heating.</param> 
  /// <exception cref="SDKException"> if not connected.</exception>
  public virtual void setChipHeatingEnabled(bool enable) {
    otcsdkPINVOKE.IRImager_setChipHeatingEnabled(swigCPtr, enable);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Return whether the sensor chip heating is enabled.</summary>
  /// <returns>true, if the sensor chip heating is enabled. False if heating is disabled of if not connected.</returns>
  public virtual bool isChipHeatingEnabled() {
    bool ret = otcsdkPINVOKE.IRImager_isChipHeatingEnabled(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Sets the reference temperature in °C for the sensor chip heating.</summary>
  /// The specified temperature should be in [20, 55] °C. If not, the temperature will automatically be clipped.
  /// The current chip temperature can be monitored with getTemperatureChip().
  /// <param name="temperature"> to set in °C.</param> 
  /// <exception cref="SDKException"> if not connected.</exception>
  public virtual void setTemperatureChipReference(float temperature) {
    otcsdkPINVOKE.IRImager_setTemperatureChipReference(swigCPtr, temperature);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns the reference temperature in °C of the sensor chip heating.</summary>
  /// <returns>temperature of the sensor chip in °C or INVALID_TEMPERATURE if not connected.</returns>
  public virtual float getTemperatureChipReference() {
    float ret = otcsdkPINVOKE.IRImager_getTemperatureChipReference(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Sets the radiation properties, i.e. emissivity and transmissivity parameters.</summary>
  /// <param name="emissivity">         of the observed object. Should be in [0, 1].</param> 
  /// <param name="transmissivity">     of the observed object. Should be in [0, 1].</param> 
  /// <param name="ambientTemperature"> in °C Set it to INVALID_TEMPERATURE or less to force the SDK to estimate the
  ///                                   ambient temperature based on thermal probe readings of the camera.</param> 
  /// <exception cref="SDKException"> if not connected or if parameters are invalid or if setting the parameters fails.</exception>
  public virtual void setRadiationParameters(float emissivity, float transmissivity, float ambientTemperature) {
    otcsdkPINVOKE.IRImager_setRadiationParameters__SWIG_0(swigCPtr, emissivity, transmissivity, ambientTemperature);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Sets the radiation properties, i.e. emissivity and transmissivity parameters.</summary>
  /// <param name="emissivity">         of the observed object. Should be in [0, 1].</param> 
  /// <param name="transmissivity">     of the observed object. Should be in [0, 1].</param> 
  /// <exception cref="SDKException"> if not connected or if parameters are invalid or if setting the parameters fails.</exception>
  public virtual void setRadiationParameters(float emissivity, float transmissivity) {
    otcsdkPINVOKE.IRImager_setRadiationParameters__SWIG_1(swigCPtr, emissivity, transmissivity);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Sets the position of the focus motor.</summary>
  /// The position should be in [0, 100] %. If not, the position will automatically be clipped.
  /// <param name="position"> focus motor position in %.</param> 
  /// <exception cref="SDKException"> if not connected or if no focus motor is available.</exception>
  public virtual void setFocusMotorPosition(float position) {
    otcsdkPINVOKE.IRImager_setFocusMotorPosition(swigCPtr, position);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns the position of the focus motor.</summary>
  /// <returns>focus motor position in % or -1.0 if not connected or if no focus motor is available.</returns>
  public virtual float getFocusMotorPosition() {
    float ret = otcsdkPINVOKE.IRImager_getFocusMotorPosition(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Returns the current precision of the thermal data.</summary>
  /// <returns>current precision of the thermal data or unknown if not connected.</returns>
  public virtual TemperaturePrecision getTemperaturePrecision() {
    TemperaturePrecision ret = (TemperaturePrecision)otcsdkPINVOKE.IRImager_getTemperaturePrecision(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  /// <summary>Sets a reference temperature to a known reference source inside the view of the device to improve measurement accuracy.</summary>
  /// <param name="referenceTemperature"> real temperature of reference source.</param> 
  /// <param name="measuredTemperature">  measured temperature from the device of reference source.</param> 
  /// <param name="ambientTemperature">   in °C. Set it to INVALID_TEMPERATURE or less to force the SDK to estimate the
  ///                                     ambient temperature based on thermal probe readings of the device.</param> 
  /// <exception cref="SDKException"> if setting the reference temperatures fails or if not connected.</exception>
  public virtual void setReferenceTemperature(float referenceTemperature, float measuredTemperature, float ambientTemperature) {
    otcsdkPINVOKE.IRImager_setReferenceTemperature__SWIG_0(swigCPtr, referenceTemperature, measuredTemperature, ambientTemperature);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Sets a reference temperature to a known reference source inside the view of the device to improve measurement accuracy.</summary>
  /// <param name="referenceTemperature"> real temperature of reference source.</param> 
  /// <param name="measuredTemperature">  measured temperature from the device of reference source.</param> 
  /// <exception cref="SDKException"> if setting the reference temperatures fails or if not connected.</exception>
  public virtual void setReferenceTemperature(float referenceTemperature, float measuredTemperature) {
    otcsdkPINVOKE.IRImager_setReferenceTemperature__SWIG_1(swigCPtr, referenceTemperature, measuredTemperature);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Sets the network configuration of the device.</summary>
  /// <param name="networkConfig"> to set.</param> 
  /// <exception cref="SDKException"> if not connect via USB or if device does not support Ethernet or if setting the device network configuration
  ///                         failed.</exception>
  public virtual void setDeviceNetworkConfig(DeviceNetworkConfig networkConfig) {
    otcsdkPINVOKE.IRImager_setDeviceNetworkConfig(swigCPtr, DeviceNetworkConfig.getCPtr(networkConfig));
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  /// <summary>Returns the network configuration of the device.</summary>
  /// <returns>network configuration of the device.</returns> 
  /// <exception cref="SDKException"> if not connect via USB or if device does not support Ethernet or if getting the device network configuration
  ///                         failed.</exception>
  public virtual DeviceNetworkConfig getDeviceNetworkConfig() {
    DeviceNetworkConfig ret = new DeviceNetworkConfig(otcsdkPINVOKE.IRImager_getDeviceNetworkConfig(swigCPtr), true);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}
