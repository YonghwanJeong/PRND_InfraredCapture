//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.3.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace Optris.OtcSDK {
///  Holds the SDK settings found in the configuration file.

public class IRImagerConfig : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal IRImagerConfig(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(IRImagerConfig obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  internal static global::System.Runtime.InteropServices.HandleRef swigRelease(IRImagerConfig obj) {
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
      global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.Dispose();
      return ptr;
    } else {
      return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
    }
  }

  ~IRImagerConfig() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          otcsdkPINVOKE.delete_IRImagerConfig(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  ///  Constructor.
  public IRImagerConfig() : this(otcsdkPINVOKE.new_IRImagerConfig(), true) {
  }

  /// <summary>Validates the configuration settings.</summary>
  /// If a faulty setting can be replaced by a valid default this method will do so automatically and
  /// print a log warning message. If no valid default is available a SDKException is throws instead.
  /// <exception cref="SDKException"> if configuration contains uncorrectable invalid settings.</exception>
  public void validate() {
    otcsdkPINVOKE.IRImagerConfig_validate(swigCPtr);
    if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
  }

  ///  Version of the configuration file.
  public int version {
    set {
      otcsdkPINVOKE.IRImagerConfig_version_set(swigCPtr, value);
    } 
    get {
      int ret = otcsdkPINVOKE.IRImagerConfig_version_get(swigCPtr);
      return ret;
    } 
  }

  ///  Serial number of the device.
  public uint serialNumber {
    set {
      otcsdkPINVOKE.IRImagerConfig_serialNumber_set(swigCPtr, value);
    } 
    get {
      uint ret = otcsdkPINVOKE.IRImagerConfig_serialNumber_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Interface used to connect to the device (USB, Ethernet).</summary>
  /// Case insensitive.
  public string connectionInterface {
    set {
      otcsdkPINVOKE.IRImagerConfig_connectionInterface_set(swigCPtr, value);
      if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    } 
    get {
      string ret = otcsdkPINVOKE.IRImagerConfig_connectionInterface_get(swigCPtr);
      if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  ///  IP address of the device.
  public IpAddress ipAddress {
    set {
      otcsdkPINVOKE.IRImagerConfig_ipAddress_set(swigCPtr, IpAddress.getCPtr(value));
    } 
    get {
      global::System.IntPtr cPtr = otcsdkPINVOKE.IRImagerConfig_ipAddress_get(swigCPtr);
      IpAddress ret = (cPtr == global::System.IntPtr.Zero) ? null : new IpAddress(cPtr, false);
      return ret;
    } 
  }

  ///  Local UDP port to which the device sends data to.
  public ushort port {
    set {
      otcsdkPINVOKE.IRImagerConfig_port_set(swigCPtr, value);
    } 
    get {
      ushort ret = otcsdkPINVOKE.IRImagerConfig_port_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Flag indicating whether to only process UDP packages from the IP address specified by the       ipAddress member variable.</summary>
  /// Set to true to activate this check or set to false to deactivate it.
  public bool checkIp {
    set {
      otcsdkPINVOKE.IRImagerConfig_checkIp_set(swigCPtr, value);
    } 
    get {
      bool ret = otcsdkPINVOKE.IRImagerConfig_checkIp_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Specifies the time in seconds that has to elapse without no new frame received until an       connection timeout occurs.</summary>
  /// If connection timeout is detected the IRImager instance will call the IRImagerClient::onConnectionTimeout()
  /// callback.
  public int connectionTimeout {
    set {
      otcsdkPINVOKE.IRImagerConfig_connectionTimeout_set(swigCPtr, value);
    } 
    get {
      int ret = otcsdkPINVOKE.IRImagerConfig_connectionTimeout_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Internal queue size for buffers holding received frames.</summary>
  /// This setting has no influence on the size of the buffers. Their size is determined by the used video
  /// format.
  public ushort bufferQueueSize {
    set {
      otcsdkPINVOKE.IRImagerConfig_bufferQueueSize_set(swigCPtr, value);
    } 
    get {
      ushort ret = otcsdkPINVOKE.IRImagerConfig_bufferQueueSize_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Width in pixels of the output frame.</summary>
  /// If width, height and framerate are all set to 0 the SDK will use the first available video format.
  public int width {
    set {
      otcsdkPINVOKE.IRImagerConfig_width_set(swigCPtr, value);
    } 
    get {
      int ret = otcsdkPINVOKE.IRImagerConfig_width_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Height in pixels of the output frame.</summary>
  /// If width, height and framerate are all set to 0 the SDK will use the first available video format.
  public int height {
    set {
      otcsdkPINVOKE.IRImagerConfig_height_set(swigCPtr, value);
    } 
    get {
      int ret = otcsdkPINVOKE.IRImagerConfig_height_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Output framerate in Hz.</summary>
  /// If width, height and framerate are all set to 0 the SDK will use the first available video format.
  public int framerate {
    set {
      otcsdkPINVOKE.IRImagerConfig_framerate_set(swigCPtr, value);
    } 
    get {
      int ret = otcsdkPINVOKE.IRImagerConfig_framerate_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Subsampled output framerate.</summary>
  /// The SDK internally reduces the output framerate to this value. This setting has no effect on the device
  /// itself, meaning the device will always send frames at the rate specified by the framerate member variable.
  /// Set to a value in [0, framerate] to achieve subsampling or set to a value to less than 0 to deactivate this
  /// feature.
  public float subsampledFramerate {
    set {
      otcsdkPINVOKE.IRImagerConfig_subsampledFramerate_set(swigCPtr, value);
    } 
    get {
      float ret = otcsdkPINVOKE.IRImagerConfig_subsampledFramerate_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Field of view of the optics in degree.</summary>
  /// If the field of view is set to 0 and the opticsText is empty the SDK will use the first available optics.
  public int fieldOfView {
    set {
      otcsdkPINVOKE.IRImagerConfig_fieldOfView_set(swigCPtr, value);
    } 
    get {
      int ret = otcsdkPINVOKE.IRImagerConfig_fieldOfView_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Optional text further specifying the used optics.</summary>
  /// If the field of view is set to 0 and the opticsText is empty the SDK will use the first available optics.
  public string opticsText {
    set {
      otcsdkPINVOKE.IRImagerConfig_opticsText_set(swigCPtr, value);
      if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    } 
    get {
      string ret = otcsdkPINVOKE.IRImagerConfig_opticsText_get(swigCPtr);
      if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  /// <summary>Lower limit of the desired temperature range in °C.</summary>
  /// Always use the temperatures for the not extended range.
  /// If the minimum and maximum temperature are set to 0 the SDK will use the first available temperature range.
  public int minTemperature {
    set {
      otcsdkPINVOKE.IRImagerConfig_minTemperature_set(swigCPtr, value);
    } 
    get {
      int ret = otcsdkPINVOKE.IRImagerConfig_minTemperature_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Upper limit of the desired temperature range in °C.</summary>
  /// Always use the temperatures for the not extended range.
  /// If the minimum and maximum temperature are set to 0 the SDK will use the first available temperature range.
  public int maxTemperature {
    set {
      otcsdkPINVOKE.IRImagerConfig_maxTemperature_set(swigCPtr, value);
    } 
    get {
      int ret = otcsdkPINVOKE.IRImagerConfig_maxTemperature_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Extends the chosen temperature range if possible.</summary>
  /// When extending the temperature range you do not need to change the values for minTemperature and maxTemperature.
  /// The range is always specified by the non extended temperatures.
  /// <remarks>Extended temperature ranges are intended to help you align the field of view of your camera. The precision</remarks>
  public bool enableExtendedTemperatureRange {
    set {
      otcsdkPINVOKE.IRImagerConfig_enableExtendedTemperatureRange_set(swigCPtr, value);
    } 
    get {
      bool ret = otcsdkPINVOKE.IRImagerConfig_enableExtendedTemperatureRange_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Use high precision temperatures if available.</summary>
  /// If true, high precision temperatures will automatically be used if the device and the chosen temperature range
  /// supports them.
  public bool enableHighPrecisionTemperature {
    set {
      otcsdkPINVOKE.IRImagerConfig_enableHighPrecisionTemperature_set(swigCPtr, value);
    } 
    get {
      bool ret = otcsdkPINVOKE.IRImagerConfig_enableHighPrecisionTemperature_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Enable the automatic triggering of flag cycles.</summary>
  /// Optris thermal cameras feature an internal shutter flag. It need to be closed periodically for the SDK to compensate
  /// for drifting temperature measurements.
  /// If set to true, flag cycles will be automatically triggered when one of the temperatures measured by internal probes
  /// changes by more than 0.1 °C.
  public bool autoFlag {
    set {
      otcsdkPINVOKE.IRImagerConfig_autoFlag_set(swigCPtr, value);
    } 
    get {
      bool ret = otcsdkPINVOKE.IRImagerConfig_autoFlag_get(swigCPtr);
      return ret;
    } 
  }

  ///  Minimum time in seconds that has to pass before a new flag cycle can be triggered.
  public float minInterval {
    set {
      otcsdkPINVOKE.IRImagerConfig_minInterval_set(swigCPtr, value);
    } 
    get {
      float ret = otcsdkPINVOKE.IRImagerConfig_minInterval_get(swigCPtr);
      return ret;
    } 
  }

  ///  Maximum time in seconds that can pass before a new flag cycle is forced.
  public float maxInterval {
    set {
      otcsdkPINVOKE.IRImagerConfig_maxInterval_set(swigCPtr, value);
    } 
    get {
      float ret = otcsdkPINVOKE.IRImagerConfig_maxInterval_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Specified how and if the sensor chip is beeing heated.</summary>
  /// The following modes are available:
  ///  - floating: The sensor chip will not be heated.
  ///  - auto    : The sensor chip will be heated to the temperature specified in the calibrations.
  ///  - fixed   : The sensor chip will be heated to the temperature specified by the chipHeatingTemperature settings.
  /// Case insensitive.
  public string chipHeatingMode {
    set {
      otcsdkPINVOKE.IRImagerConfig_chipHeatingMode_set(swigCPtr, value);
      if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
    } 
    get {
      string ret = otcsdkPINVOKE.IRImagerConfig_chipHeatingMode_get(swigCPtr);
      if (otcsdkPINVOKE.SWIGPendingException.Pending) throw otcsdkPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  ///  Temperature in °C for the fixed chipHeatingMode.
  public float chipHeatingTemperature {
    set {
      otcsdkPINVOKE.IRImagerConfig_chipHeatingTemperature_set(swigCPtr, value);
    } 
    get {
      float ret = otcsdkPINVOKE.IRImagerConfig_chipHeatingTemperature_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Position of the focus motor in % ([0, 100]).</summary>
  /// Should be in [0., 100.]. Set to a value less than 0 for the SDK to ignore this setting.
  public float focusMotorPosition {
    set {
      otcsdkPINVOKE.IRImagerConfig_focusMotorPosition_set(swigCPtr, value);
    } 
    get {
      float ret = otcsdkPINVOKE.IRImagerConfig_focusMotorPosition_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Emissivity of the observed object.</summary>
  /// Should be in [0., 1.].
  public float emissivity {
    set {
      otcsdkPINVOKE.IRImagerConfig_emissivity_set(swigCPtr, value);
    } 
    get {
      float ret = otcsdkPINVOKE.IRImagerConfig_emissivity_get(swigCPtr);
      return ret;
    } 
  }

  ///  Transmissivity.
  /// <summary>Transmissivity of the observed object.</summary>
  /// Should be in [0. , 1.].
  public float transmissivity {
    set {
      otcsdkPINVOKE.IRImagerConfig_transmissivity_set(swigCPtr, value);
    } 
    get {
      float ret = otcsdkPINVOKE.IRImagerConfig_transmissivity_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Ambient temperature in °C.</summary>
  /// Set to INVALID_TEMPERATURE or less to force the SDK to estimate the ambient temperature based on reading of
  /// the internal probes of the device.
  public float ambientTemperature {
    set {
      otcsdkPINVOKE.IRImagerConfig_ambientTemperature_set(swigCPtr, value);
    } 
    get {
      float ret = otcsdkPINVOKE.IRImagerConfig_ambientTemperature_get(swigCPtr);
      return ret;
    } 
  }

  /// <summary>Activate multithreading for postprocessing.</summary>
  /// <remarks>Experimental setting.</remarks>
  public bool enableMultiThreading {
    set {
      otcsdkPINVOKE.IRImagerConfig_enableMultiThreading_set(swigCPtr, value);
    } 
    get {
      bool ret = otcsdkPINVOKE.IRImagerConfig_enableMultiThreading_get(swigCPtr);
      return ret;
    } 
  }

}

}
